#include "mavlink_uart.h"

uint16_t uart_rx_buffer[MAVLINK_MAX_PACKET_LEN];
uint16_t uart_tx_buffer[MAVLINK_MAX_PACKET_LEN];

mavlink_pso_command_t command;


mavlink_system_t mavlink_system;

// Write message on 'Gumstix_Message_out'
void uart_write ( )
{
	int i, bytes;
	uint16_t *u;


	mavlink_pso_data_t dp;
	mavlink_message_t msg;

    mavlink_system.sysid = 0;
    mavlink_system.compid = MAV_COMP_ID_IMU;
//    mavlink_system.type = MAV_TYPE_FIXED_WING;
//    mavlink_system.state = MAV_STATE_BOOT;
//    mavlink_system.mode = MAV_MODE_PREFLIGHT;
//    mavlink_system.nav_mode = 0;


    memset(&dp, 0, sizeof(dp));

    dp.accel[0] = 120;	/* x-axis vibration */
    dp.accel[1] = 120;  /* y-axis vibration */
    dp.accel[2] = 120;  /* z-axis vibration */
    dp.rpm = 1750U;     /* Revolutions per minute */
    dp.i_motor = 17;    /* Current of the motor, [A] */
    dp.v_motor = 11.6;  /* Voltage applied to the motor, [V] */
    dp.thrust = 23;     /* Force generated by the motor + propeller, [N] */

    /*
	// Attitude
    dp.att_est[0] = DEG2RAD * ekf_states->phi;
	dp.att_est[1] = DEG2RAD * ekf_states->theta;
	dp.att_est[2] = DEG2RAD * ekf_states->psi;

	// Airspeed
	dp.airspeed = i2c_dat->diff_press; //TODO: must be implemented
	// Altitude
	dp.altitude = (int32)(i2c_dat->abs_press); //TODO: must be implemented

	// Accelerometer (correcting sign)
	dp.acc[0] = - i2c_dat->A_x;
	dp.acc[1] = - i2c_dat->A_y;
	dp.acc[2] = - i2c_dat->A_z;
	*/                                                        // Horizontal Dilution of Precision

	/*printf("att_est %f %f %f\n", dp.att_est[0], dp.att_est[1], dp.att_est[2]);
	printf("airspeed %u\n", dp.airspeed);
	printf("altitude %ld\n", dp.altitude);
	printf("acc %d %d %d\n", dp.acc[0], dp.acc[1], dp.acc[2]);
	*/


	memset(uart_tx_buffer, 0, sizeof(uart_tx_buffer));
	//memset(Gumstix_Message_out, 0x0f07, sizeof(Gumstix_Message_out));

	create_message(mavlink_system.sysid, mavlink_system.compid, GUMSTIX_COMM_CHANNEL, uart_tx_buffer, &dp);

	bytes = (MAVLINK_MSG_ID_PSO_DATA_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES)/2;
/*
	for(i=0; i<bytes; ++i){
		if(i%10==0)
			printf("\n");
		//c = (int32) Gumstix_Message_out[i];
		printf("%u, %u; ", (Gumstix_Message_out[i]) & 0xff, (Gumstix_Message_out[i] >> 8) & 0xff);
	}
	printf("\n");
	printf("\nSTART DP\n");
	u = (uint16_t *) &dp;
	for(i=0; i<(int)sizeof(dp); ++i){
		if(i%10==0)
			printf("\n");
		//c = (int32) Gumstix_Message_out[i];
		printf("%u, %u; ", (*u) & 0xff, (*u >> 8) & 0xff);
		u++;
	}
	printf("\nEND DP\n");
*/

}



// Read from 'Gumstix_Message_in' and translate message to variable 'command'.
int uart_read(){
	mavlink_message_t msg;
	mavlink_status_t status;
	int i;
	uint16_t buffer[MAVLINK_MSG_ID_PSO_COMMAND_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES];

	//if(Gumstix_Message_in[0] != 0xfe)
	//	return -1;

	memset(buffer, 0, sizeof(buffer));

	//printf("\nGUMSTIX_INFORMATION: Reading new message...\n");

	mavlink_reset_channel_status(GUMSTIX_COMM_CHANNEL);

	for (i = 0; i < MAVLINK_MSG_ID_PSO_COMMAND_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES; i++){
		if(i%2==0){
			buffer[i/2] |= uart_rx_buffer[i];
		}else{
			buffer[i/2] |= uart_rx_buffer[i] << 8;
		}
				//if(i%10==0)
				//	printf("\n");

				//printf("%d=%d,", i, (int)Gumstix_Message_in[i]);
	}
	if(parse_message(buffer, &command)){
	    //Retrieve the message payload and return

		printf("\nGUMSTIX_INFORMATION: New message read\n");
		//printf("\nAileron %u, Elevator %u, Throttle %u, Rudder %u.\n", command.aileron, command.elevator, command.throttle, command.rudder);
	    // SUCCESS
	    return 0;
	}

	//printf("\nGUMSTIX_INFORMATION: Failed to parse message...\n");
	// FAIL
	return -1;

}
